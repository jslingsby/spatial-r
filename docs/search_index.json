[["rdemo.html", "7 Vector GIS operations in R 7.1 Case study and demo datasets 7.2 Reading and writing 7.3 Basic plotting 7.4 Cropping 7.5 Select and subset by attribute 7.6 Combine classes and dissolve by attribute 7.7 Calling iNaturalist locality (point) data from R 7.8 Converting a dataframe into a spatial object 7.9 Adding basemaps to plots 7.10 Interactive maps with leaflet and mapview 7.11 Reprojecting 7.12 Intersecting points and polygons 7.13 Colour or label points 7.14 Buffering 7.15 Within distance and intersect", " 7 Vector GIS operations in R 7.1 Case study and demo datasets Ok, for demonstrating some of the many GIS operations R can perform we will be using data from one of my favourite study areas, the Cape Peninsula. The datasets we will use, some of their properties and where to source them are tabled below. You can also download them as one (40MB) .zip file here, because the City of Cape Town updates the files from time to time and small changes in format, naming etc break the code to come. Please do not use the version from the .zip file in any real analyses etc, because I can make no guarantees about their accuracy etc. It is best to use the latest version from the links in the table. Name Data source Data model Geometry type File format Localities iNaturalist Vector Point Data frame from API Watercourses City of Cape Town Vector Line ESRI shapefile Vegetation Types (historical) City of Cape Town Vector Polygon ESRI shapefile Vegetation Types (remnants) City of Cape Town Vector Polygon ESRI shapefile Elevation City of Cape Town Raster Raster MapServer If you’d like to follow along and run the analyses that follow, please download the datasets. There’s no need to download the iNaturalist data as we’ll download it directly from R. For installing R and the required packages see section 1.2. 7.2 Reading and writing sf has a one-size-fits-all approach in that most functions can be applied to most different data types (point, line, polygon, etc) or, in the case of reading and writing, file formats. To read data the function you want is st_read(). You’ll note that most of the sf functions begin with “st_” - this stands for “spatial and temporal” and is the same in some other GIS like PostGIS. Let’s try to read in some data with st_read(): NOTE: if you’re trying any of the read/write code at home, you’ll need to set the file path to where you put the data and want the outputs on your local machine. You can also use ?setwd to simplify this. If you are on Windows, make sure to change the backslashes to either double backslashes or forward slashes “/”. library(sf) veg &lt;- st_read(&quot;data/cape_peninsula/veg/Vegetation_Indigenous.shp&quot;) ## Reading layer `Vegetation_Indigenous&#39; from data source ## `/Users/jasper/GIT/spatial-r/data/cape_peninsula/veg/Vegetation_Indigenous.shp&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 1325 features and 5 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: -63972.95 ymin: -3803535 xmax: 430.8125 ymax: -3705149 ## Projected CRS: WGS_1984_Transverse_Mercator This has successfully read in the data and given us a summary of some of its properties. Note the “Projected CRS” WGS_1984_Transverse_Mercator, so it is Transverse Mercator (TM), using the WGS84 datum, but it hasn’t told us what line of longitude it’s centred on, which is an essential feature of any TM projection. The first thing you should do when interrogating any spatial data is to check the coordinate reference system (CRS). In sf, you do this with the function st_crs, like so: st_crs(veg) ## Coordinate Reference System: ## User input: WGS_1984_Transverse_Mercator ## wkt: ## PROJCRS[&quot;WGS_1984_Transverse_Mercator&quot;, ## BASEGEOGCRS[&quot;WGS 84&quot;, ## DATUM[&quot;Hartebeesthoek94&quot;, ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]], ## ID[&quot;EPSG&quot;,6148]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;Degree&quot;,0.0174532925199433]]], ## CONVERSION[&quot;unnamed&quot;, ## METHOD[&quot;Transverse Mercator&quot;, ## ID[&quot;EPSG&quot;,9807]], ## PARAMETER[&quot;Latitude of natural origin&quot;,0, ## ANGLEUNIT[&quot;Degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8801]], ## PARAMETER[&quot;Longitude of natural origin&quot;,19, ## ANGLEUNIT[&quot;Degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8802]], ## PARAMETER[&quot;Scale factor at natural origin&quot;,1, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8805]], ## PARAMETER[&quot;False easting&quot;,0, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8806]], ## PARAMETER[&quot;False northing&quot;,0, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8807]]], ## CS[Cartesian,2], ## AXIS[&quot;(E)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;metre&quot;,1, ## ID[&quot;EPSG&quot;,9001]]], ## AXIS[&quot;(N)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;metre&quot;,1, ## ID[&quot;EPSG&quot;,9001]]]] This shows us the CRS as a WKT string and looks very complicated… Essentially there are three components to it: BASEGEOGCRS - the geographic (or unprojected) CRS CONVERSION - the projection, which includes a lot of information, but essentially tells us it’s Transverse Mercator, and the \"Longitude of natural origin\",19 indicates that it is centred on the 19 degree line of longitude (i.e. we’re dealing with Transverse Mercator Lo19) CS - the cartesian axes, showing that we’re dealing with axes oriented to North and East and units of metres TM Lo19 is a good projection for most calculations at this scale (and on this line of longitude). If you’re using Transverse Mercator, always make sure it is set for your closest “odd” line of longitude (i.e. Lo19, Lo21, Lo23)! More on working with coordinate reference systems in see section 7.11. Let’s have a closer look at the data: class(veg) ## [1] &quot;sf&quot; &quot;data.frame&quot; It is an object of two different “classes”, a data.frame, which is an R object class you should be familiar with, and class sf, which is the native class for the sf library. The nice thing about being both classes is it means you can apply the functions built for either class, such as head, a commonly used function for looking at the first few rows of a dataframe. head(veg) ## Simple feature collection with 6 features and 5 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: -51324.95 ymin: -3732075 xmax: -35653.98 ymax: -3718136 ## Projected CRS: WGS_1984_Transverse_Mercator ## AREA_HCTR PRMT_MTR National_ Subtype ## 1 1807.5183616 24763.8073 Atlantis Sand Fynbos on marine-derived acid sands ## 2 2.1437754 609.5892 Atlantis Sand Fynbos on marine-derived acid sands ## 3 0.2134855 185.5566 Atlantis Sand Fynbos on marine-derived acid sands ## 4 2.8602421 652.1671 Atlantis Sand Fynbos on marine-derived acid sands ## 5 0.5468058 336.8006 Atlantis Sand Fynbos on marine-derived acid sands ## 6 0.4172046 259.7772 Atlantis Sand Fynbos on marine-derived acid sands ## Community geometry ## 1 Need to Find Out POLYGON ((-48203.88 -372294... ## 2 Need to Find Out POLYGON ((-36676.72 -371974... ## 3 Need to Find Out POLYGON ((-35891.46 -371837... ## 4 Need to Find Out POLYGON ((-35750.07 -371847... ## 5 Need to Find Out POLYGON ((-35823.89 -371817... ## 6 Need to Find Out POLYGON ((-35929.18 -371824... Note there are 5 attribute columns (the attribute table as you would see in most GIS software) and a 6th geometry column. All sf objects have a geometry column. This is where it stores the geometry - i.e. the point, line, polygon etc - associated with each row of attribute data. To write data with sf you use st_write(), like so: st_write(veg, &quot;data/cape_peninsula/veg/Vegetation_Indigenous_duplicate.shp&quot;, append = FALSE) ## Writing layer `Vegetation_Indigenous_duplicate&#39; to data source ## `data/cape_peninsula/veg/Vegetation_Indigenous_duplicate.shp&#39; using driver `ESRI Shapefile&#39; ## Writing 1325 features with 5 fields and geometry type Polygon. Note that I added , append = FALSE because in my case it I want it to overwrite an existing file by the same name, and this command suppresses the warning it would usually give. file.exists(&quot;data/cape_peninsula/veg/Vegetation_Indigenous_duplicate.shp&quot;) ## [1] TRUE Confirms that the file exists, so it has written a file out successfully. Note that the function recognised that I wanted to write out an ESRI shapefile from the .shp file extension I provided. You can set the file type using the driver = setting in st_write(). Try st_drivers() for the list of file types supported. 7.3 Basic plotting As with other data types in R (and perhaps even more so with spatial data), you can really go to town with plotting. I’m only going to show you enough to be able to interrogate your data. Making it look pretty is a week-long course or more in its own right. Check out the “Making maps with R” chapter in Lovelace et al’s online book Geocomputation with R for a good start. You could also check out library(tmap) for plotting thematic maps or library(mapview) for interactive maps. The easiest way to plot datasets in R is often a bad thing to do when working with spatial datasets! plot(veg) Fortunately, in this case the dataset isn’t too big, but often you’ll either be overwhelmed with plots or your computer will crash… Why 5 plots and not one? This is because sf wants to plot the properties of each attribute in the attribute table. Fortunately, there were only 5, but there could have been hundreds! You can select the one you want with indexing like so: plot(veg[3]) These are the National Vegetation Types for the City of Cape Town municipality. You’ll note that we’re using the base R graphics functions. I mentioned before that sf integrates well with the Tidyverse, so this could also be plotted like so: library(tidyverse) #calls ggplot2 and other Tidyverse packages together ggplot() + geom_sf(data=veg, aes(fill = `National_`)) That’s better for the legend, but now we’ve squashed the map. Let’s narrow in on the Cape Peninsula for convenience. 7.4 Cropping Here we’ll apply the function st_crop(). To use the function you need an object to crop, and an extent or bounding box to crop to. sf is clever, and you can set the extent by giving it another object who’s extent you’d like to match (check the bounding box given when we read in the data earlier). We don’t have a second object in this case, so we have to provide a “numeric vector with named elements xmin, ymin, xmax and ymax”, like so: #Make a vector with desired coordinates in metres according to TM Lo19 ext &lt;- c(-66642.18, -3809853.29, -44412.18, -3750723.29) ext ## [1] -66642.18 -3809853.29 -44412.18 -3750723.29 #Give the vector names names(ext) &lt;- c(&quot;xmin&quot;, &quot;ymin&quot;, &quot;xmax&quot;, &quot;ymax&quot;) ext ## xmin ymin xmax ymax ## -66642.18 -3809853.29 -44412.18 -3750723.29 Now we can feed that into st_crop veg &lt;- st_crop(veg, ext) #Note that I&#39;m overwriting the old data object &quot;veg&quot; ## Warning: attribute variables are assumed to be spatially constant throughout all ## geometries ggplot() + geom_sf(data=veg, aes(fill = `National_`)) Better? But what about the silly splits like Peninsula Granite Fynbos - North/South and Cape Flats Dune Strandveld - West Coast/False Bay. Which ones do I mean? 7.5 Select and subset by attribute Let’s select them from the attribute table and plot them. #Make a vector of the veg types we want split_veg &lt;- c(&quot;Peninsula Granite Fynbos - North&quot;, &quot;Peninsula Granite Fynbos - South&quot;, &quot;Cape Flats Dune Strandveld - West Coast&quot;, &quot;Cape Flats Dune Strandveld - False Bay&quot;) #Use base R indexing to select attributes vegsub &lt;- veg[which(veg$National_ %in% split_veg),] #Plot ggplot() + geom_sf(data=vegsub, aes(fill = `National_`)) Or tidyverse… #Using tidyverse piping to filter and plot veg %&gt;% filter(National_ %in% split_veg) %&gt;% ggplot() + geom_sf(aes(fill = `National_`)) #The advantage being that you don&#39;t have to make the intermediate &quot;vegsub&quot; object Ok. What if we decided we don’t want them split? 7.6 Combine classes and dissolve by attribute We can just rename them in appropriate column in the attribute table… vegsub$National_ &lt;- str_replace_all(vegsub$National_, c(&quot;Peninsula Granite Fynbos - North&quot; = &quot;Peninsula Granite Fynbos&quot;, &quot;Peninsula Granite Fynbos - South&quot; = &quot;Peninsula Granite Fynbos&quot;, &quot;Cape Flats Dune Strandveld - West Coast&quot; = &quot;Cape Flats Dune Strandveld&quot;, &quot;Cape Flats Dune Strandveld - False Bay&quot; = &quot;Cape Flats Dune Strandveld&quot;)) ggplot() + geom_sf(data=vegsub, aes(fill = `National_`)) Nice, but from the polygon boundaries we see that there are a number of adjacent polygons (i.e. they have shared boundaries) that are of the same veg type. We can “dissolve” and plot it without the unwanted boundaries using summarize(): vegsub %&gt;% group_by(National_) %&gt;% summarize() %&gt;% ggplot() + geom_sf(aes(fill = National_)) Ok… I think we’ve flogged that horse as far as it’ll go for now. Let’s bring in another dataset. How about points? 7.7 Calling iNaturalist locality (point) data from R A very cool feature of iNaturalist is that the team at rOpenSci have built a great R package for interfacing with it directly, called rinat! Let’s get all the records we can for the King Protea (Protea cynaroides). library(rinat) #Call the data directly from iNat pc &lt;- get_inat_obs(taxon_name = &quot;Protea cynaroides&quot;, bounds = c(-35, 18, -33.5, 18.5), maxresults = 1000) #View the first few rows of data head(pc) ## scientific_name datetime description ## 1 Protea cynaroides 2024-02-18 11:06:57 +0200 ## 2 Protea cynaroides 2024-02-18 13:29:11 +0200 ## 3 Protea cynaroides 2024-02-18 07:50:17 +0200 ## 4 Protea cynaroides 2024-02-17 11:08:16 +0200 ## 5 Protea cynaroides 2024-02-17 11:35:46 +0200 ## 6 Protea cynaroides 2024-02-17 08:46:37 +0200 ## place_guess latitude longitude tag_list ## 1 Table Mountain (Nature Reserve), Cape Town, South Africa -33.96553 18.41059 ## 2 Table Mountain National Park, ZA-WC-CT, ZA-WC, ZA -33.96780 18.42637 ## 3 Table Mountain National Park, Cape Town, WC, ZA -34.00400 18.40527 ## 4 Table Mountain National Park, ZA-WC-CT, ZA-WC, ZA -34.06891 18.39379 ## 5 Silver Mine (Nature Reserve), Cape Town, South Africa -34.11639 18.44388 ## 6 Table Mountain National Park, ZA-WC-CT, ZA-WC, ZA -33.96591 18.41101 ## common_name url ## 1 King Protea https://www.inaturalist.org/observations/199880775 ## 2 King Protea https://www.inaturalist.org/observations/199706446 ## 3 King Protea https://www.inaturalist.org/observations/199658012 ## 4 King Protea https://www.inaturalist.org/observations/199597143 ## 5 King Protea https://www.inaturalist.org/observations/199583340 ## 6 King Protea https://www.inaturalist.org/observations/199534840 ## image_url ## 1 https://inaturalist-open-data.s3.amazonaws.com/photos/352554820/medium.jpeg ## 2 https://inaturalist-open-data.s3.amazonaws.com/photos/352228494/medium.jpeg ## 3 https://inaturalist-open-data.s3.amazonaws.com/photos/352137332/medium.jpg ## 4 https://inaturalist-open-data.s3.amazonaws.com/photos/352016448/medium.jpeg ## 5 https://inaturalist-open-data.s3.amazonaws.com/photos/351990638/medium.jpeg ## 6 https://static.inaturalist.org/photos/351899776/medium.jpeg ## user_login id species_guess iconic_taxon_name taxon_id ## 1 susanthescout 199880775 Giant Protea Plantae 132848 ## 2 dryfveer 199706446 King Protea Plantae 132848 ## 3 cajacobs 199658012 King Protea Plantae 132848 ## 4 sashie889 199597143 Giant Protea Plantae 132848 ## 5 dryfveer 199583340 King Protea Plantae 132848 ## 6 joevasscapecub 199534840 King Protea Plantae 132848 ## num_identification_agreements num_identification_disagreements observed_on_string ## 1 3 0 2024-02-18 11:06:57 ## 2 1 0 2024-02-18 13:29:11 ## 3 2 0 2024-02-18 07:50:17+02:00 ## 4 2 0 2024-02-17 11:08:16 ## 5 0 0 2024-02-17 11:35:46 ## 6 3 0 2024-02-17 08:46:37 ## observed_on time_observed_at time_zone positional_accuracy ## 1 2024-02-18 2024-02-18 09:06:57 UTC Pretoria 4 ## 2 2024-02-18 2024-02-18 11:29:11 UTC Pretoria 12 ## 3 2024-02-18 2024-02-18 05:50:17 UTC Pretoria 4 ## 4 2024-02-17 2024-02-17 09:08:16 UTC Pretoria 8 ## 5 2024-02-17 2024-02-17 09:35:46 UTC Pretoria 4 ## 6 2024-02-17 2024-02-17 06:46:37 UTC Pretoria 3 ## public_positional_accuracy geoprivacy taxon_geoprivacy coordinates_obscured ## 1 4 &lt;NA&gt; open false ## 2 12 &lt;NA&gt; open false ## 3 4 &lt;NA&gt; open false ## 4 8 &lt;NA&gt; open false ## 5 4 &lt;NA&gt; open false ## 6 3 &lt;NA&gt; open false ## positioning_method positioning_device user_id user_name created_at ## 1 gps gps 1495441 Susan Gammon 2024-02-20 09:25:06 UTC ## 2 2173153 Santie Gouws 2024-02-18 19:22:46 UTC ## 3 7637674 2024-02-18 10:26:50 UTC ## 4 5301909 2024-02-17 20:25:20 UTC ## 5 2173153 Santie Gouws 2024-02-17 18:19:29 UTC ## 6 5607386 Joe Vass 2024-02-17 06:48:00 UTC ## updated_at quality_grade license sound_url oauth_application_id ## 1 2024-02-20 11:39:37 UTC research CC-BY-NC NA 2 ## 2 2024-02-18 19:23:23 UTC research CC-BY-NC NA 2 ## 3 2024-02-19 10:31:13 UTC research CC-BY-NC NA 3 ## 4 2024-02-19 10:46:22 UTC research CC-BY-NC NA 2 ## 5 2024-02-17 18:21:24 UTC needs_id CC-BY-NC NA 2 ## 6 2024-02-19 10:42:24 UTC research NA 2 ## captive_cultivated ## 1 false ## 2 false ## 3 false ## 4 false ## 5 false ## 6 false #Filter returned observations by a range of column attribute criteria pc &lt;- pc %&gt;% filter(positional_accuracy&lt;46 &amp; latitude&lt;0 &amp; !is.na(latitude) &amp; captive_cultivated == &quot;false&quot; &amp; quality_grade == &quot;research&quot;) class(pc) ## [1] &quot;data.frame&quot; Ok, so this is a dataframe with lat/long data, but it isn’t registered as an object with spatial attributes (i.e. geometries). 7.8 Converting a dataframe into a spatial object To make it an object of class(sf) we use the function st_as_sf(). #Make the dataframe a spatial object of class = &quot;sf&quot; pc &lt;- st_as_sf(pc, coords = c(&quot;longitude&quot;, &quot;latitude&quot;), crs = 4326) Note that I had to define the CRS!!! I defined it to be Geographic WGS84, using the EPSG code in this case. Recall the difference between defining and CRS and projecting of transforming the CRS as discussed in yesterday’s notes… #What class is it? class(pc) ## [1] &quot;sf&quot; &quot;data.frame&quot; #Note the new &quot;geometry&quot; column names(pc) ## [1] &quot;scientific_name&quot; &quot;datetime&quot; ## [3] &quot;description&quot; &quot;place_guess&quot; ## [5] &quot;tag_list&quot; &quot;common_name&quot; ## [7] &quot;url&quot; &quot;image_url&quot; ## [9] &quot;user_login&quot; &quot;id&quot; ## [11] &quot;species_guess&quot; &quot;iconic_taxon_name&quot; ## [13] &quot;taxon_id&quot; &quot;num_identification_agreements&quot; ## [15] &quot;num_identification_disagreements&quot; &quot;observed_on_string&quot; ## [17] &quot;observed_on&quot; &quot;time_observed_at&quot; ## [19] &quot;time_zone&quot; &quot;positional_accuracy&quot; ## [21] &quot;public_positional_accuracy&quot; &quot;geoprivacy&quot; ## [23] &quot;taxon_geoprivacy&quot; &quot;coordinates_obscured&quot; ## [25] &quot;positioning_method&quot; &quot;positioning_device&quot; ## [27] &quot;user_id&quot; &quot;user_name&quot; ## [29] &quot;created_at&quot; &quot;updated_at&quot; ## [31] &quot;quality_grade&quot; &quot;license&quot; ## [33] &quot;sound_url&quot; &quot;oauth_application_id&quot; ## [35] &quot;captive_cultivated&quot; &quot;geometry&quot; #Plot ggplot() + geom_sf(data=pc) Great! We got lots of points, but without a base layer its very difficult to tell where exactly these are? 7.9 Adding basemaps to plots There are lots of ways to make the basemap from data objects etc that we can plot our points over, but an easy way is to pull in tiles from Open Street Maps and plot our points on those. library(rosm) library(ggspatial) ggplot() + annotation_map_tile(type = &quot;osm&quot;, progress = &quot;none&quot;) + geom_sf(data=pc) Note that there are quite a few base layer/tile options that can be set with type = \"\". Try rosm::osm.types() to see them all. This is better than nothing, but the scale of the map is too small to really see where the plants actually are. It would be much easier if we could look at the data interactively? 7.10 Interactive maps with leaflet and mapview We can generate interactive maps by calling the leaflet mapserver using wrapper functions in the leaflet R package written for this purpose. NOTE: If you can’t get leaflet to work it is probably a CRS problem. Your data need to be in Geographic or Web Mercator library(leaflet) library(htmltools) leaflet() %&gt;% # Add default OpenStreetMap map tiles addTiles(group = &quot;Default&quot;) %&gt;% # Add our points addCircleMarkers(data = pc, group = &quot;Protea cynaroides&quot;, radius = 3, color = &quot;green&quot;) Much better! Strange, but even though we filtered our iNaturalist records for captive_cultivated == \"false\" we still have a number of observations that appear to be in people’s gardens. Let this serve as a warning to be wary of all data! Always do “common-sense-checks” on your data and the outputs of your analyses!!! One way to do common sense checks with interactive plots is to add popup labels that allow you to inspect the data. See here to do this with library(leaflet), but here’s an example with library(mapview). library(mapview) library(leafpop) mapview(pc, popup = popupTable(pc, zcol = c(&quot;user_login&quot;, &quot;captive_cultivated&quot;, &quot;url&quot;))) Nice, but we can’t click on the URL, we have to copy and paste it. Fortunately, with a little html formatting we can make them live links. lpc &lt;- pc %&gt;% mutate(click_url = paste(&quot;&lt;b&gt;&lt;a href=&#39;&quot;, url, &quot;&#39;&gt;Link to iNat observation&lt;/a&gt;&lt;/b&gt;&quot;)) mapview(pc, popup = popupTable(lpc, zcol = c(&quot;user_login&quot;, &quot;captive_cultivated&quot;, &quot;click_url&quot;))) 7.11 Reprojecting One way to drastically reduce the number of cultivated records is to overlay the localities (points) with the remaining extent of the vegetation types (i.e. anything that is not in natural vegtation is likely to be cultivated). Let’s try that… #Get the remnants layer vegr &lt;- st_read(&quot;data/cape_peninsula/veg/Vegetation_Indigenous_Remnants.shp&quot;) ## Reading layer `Vegetation_Indigenous_Remnants&#39; from data source ## `/Users/jasper/GIT/spatial-r/data/cape_peninsula/veg/Vegetation_Indigenous_Remnants.shp&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 3428 features and 7 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: -63951.23 ymin: -3803532 xmax: 420.7595 ymax: -3705506 ## Projected CRS: WGS_1984_Transverse_Mercator hmm &lt;- st_intersection(pc, vegr) ## Error in geos_op2_geom(&quot;intersection&quot;, x, y, ...): st_crs(x) == st_crs(y) is not TRUE Oops! The Coordinate Reference Systems are different! We will need to reproject one of the two datasets… Let’s see what CRS are currently set: st_crs(pc) ## Coordinate Reference System: ## User input: EPSG:4326 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## ENSEMBLE[&quot;World Geodetic System 1984 ensemble&quot;, ## MEMBER[&quot;World Geodetic System 1984 (Transit)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G730)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G873)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G1150)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G1674)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G1762)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G2139)&quot;], ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]], ## ENSEMBLEACCURACY[2.0]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;geodetic latitude (Lat)&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;geodetic longitude (Lon)&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## USAGE[ ## SCOPE[&quot;Horizontal component of 3D system.&quot;], ## AREA[&quot;World.&quot;], ## BBOX[-90,-180,90,180]], ## ID[&quot;EPSG&quot;,4326]] So the points are Geographic, with no projected CRS CONVERSION. st_crs(vegr) ## Coordinate Reference System: ## User input: WGS_1984_Transverse_Mercator ## wkt: ## PROJCRS[&quot;WGS_1984_Transverse_Mercator&quot;, ## BASEGEOGCRS[&quot;WGS 84&quot;, ## DATUM[&quot;Hartebeesthoek94&quot;, ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]], ## ID[&quot;EPSG&quot;,6148]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;Degree&quot;,0.0174532925199433]]], ## CONVERSION[&quot;unnamed&quot;, ## METHOD[&quot;Transverse Mercator&quot;, ## ID[&quot;EPSG&quot;,9807]], ## PARAMETER[&quot;Latitude of natural origin&quot;,0, ## ANGLEUNIT[&quot;Degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8801]], ## PARAMETER[&quot;Longitude of natural origin&quot;,19, ## ANGLEUNIT[&quot;Degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8802]], ## PARAMETER[&quot;Scale factor at natural origin&quot;,1, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8805]], ## PARAMETER[&quot;False easting&quot;,0, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8806]], ## PARAMETER[&quot;False northing&quot;,0, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8807]]], ## CS[Cartesian,2], ## AXIS[&quot;(E)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;metre&quot;,1, ## ID[&quot;EPSG&quot;,9001]]], ## AXIS[&quot;(N)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;metre&quot;,1, ## ID[&quot;EPSG&quot;,9001]]]] The remnants of vegetation types are in Transverse Mercator Lo19, just like the dataset of the historical extent of the veg types we were working with earlier. In this case, either CRS is fine for our purposes, but let’s stick with Transverse Mercator Lo19, because it’ll be useful later. For this we need to project the points like so: pc &lt;- st_transform(pc, st_crs(vegr)) Note that I fed it the CRS from vegr. This guarantees that they’ll be the same, even if we misidentified what the actual CRS is… 7.12 Intersecting points and polygons …and now we can try to intersect the points and polygons again… First lets see how many rows and columns the point data before the intersection: #call the dimensions of pc dim(pc) ## [1] 662 36 And after the intersection? pc &lt;- st_intersection(pc, vegr) ## Warning: attribute variables are assumed to be spatially constant throughout all ## geometries dim(pc) ## [1] 649 43 Less rows, but more columns! Two things have happened: The attribute data from the polygons in vegr intersected by the points in pc have been added to the attribute table in pc! All points that do not intersect the polygons in vegr were dropped (i.e. those that were recorded outside the remaining extent of natural vegetation). Let’s have a look ggplot() + annotation_map_tile(type = &quot;osm&quot;, progress = &quot;none&quot;) + geom_sf(data=pc) Yup, the localities in suburbia are gone… The map is a bit bland though. How about we use our “new information” about which vegetation types the observations occur in to colour or label the points on the map? 7.13 Colour or label points First, let’s add colour: library(wesanderson) pal &lt;- wes_palette(&quot;Darjeeling1&quot;, 7, type = &quot;continuous&quot;) ggplot() + annotation_map_tile(type = &quot;osm&quot;, progress = &quot;none&quot;) + geom_sf(data=pc, aes(col = National_)) + scale_colour_manual(values = pal) Looks like almost all of them are in Peninsula Sandstone Fynbos… pc %&gt;% group_by(National_) %&gt;% summarise(n()) ## Simple feature collection with 7 features and 2 fields ## Geometry type: GEOMETRY ## Dimension: XY ## Bounding box: xmin: -62094.02 ymin: -3797540 xmax: -48638.23 ymax: -3755805 ## Projected CRS: WGS_1984_Transverse_Mercator ## # A tibble: 7 × 3 ## National_ `n()` geometry ## &lt;chr&gt; &lt;int&gt; &lt;GEOMETRY [m]&gt; ## 1 Cape Flats Sand Fynbos 2 MULTIPOINT ((-53325.87 -3769939), (-53306.33 -376… ## 2 Hangklip Sand Fynbos 8 MULTIPOINT ((-52805.82 -3780199), (-52780.97 -378… ## 3 Peninsula Granite Fynbos - North 1 POINT (-55987.76 -3757205) ## 4 Peninsula Granite Fynbos - South 2 MULTIPOINT ((-53290.55 -3763665), (-49759.88 -377… ## 5 Peninsula Sandstone Fynbos 633 MULTIPOINT ((-62094.02 -3767667), (-62038.23 -376… ## 6 Peninsula Shale Renosterveld 1 POINT (-55866.33 -3755805) ## 7 Southern Afrotemperate Forest 2 MULTIPOINT ((-53668.51 -3762128), (-53645.86 -376… Yup! Note the numbers in column n(). But I can’t see where the Hangklip Sand Fynbos record is, so let’s label that one with text using geom_sf_label(). hsf &lt;- pc %&gt;% filter(National_ == &quot;Hangklip Sand Fynbos&quot;) #find the locality ggplot() + annotation_map_tile(type = &quot;osm&quot;, progress = &quot;none&quot;) + geom_sf(data=pc, aes(col = National_)) + scale_colour_manual(values = pal) + geom_sf_label(data=hsf, aes(label = &quot;Here&quot;)) Aha! Note that you can specify that the label = setting points to a column in your dataset with names if you have lots of labels to add. 7.14 Buffering One issue here may be that all localities should be in Peninsula Sandstone Fynbos, but the vegetation type boundaries are wrong. After all, the transition or ecotone between two vegetation types is usually diffuse rather than a clear boundary, not to mention that the data may have been digitized at a very small scale, compromizing precision and accuracy. One way to check this is to buffer the points using st_buffer to see if they are within some distance (say 250m) of the boundary with Peninsula Sandstone Fynbos. #Find the localities that are not in Peninsula Sandstone Fynbos and add a 250m buffer npsf &lt;- pc %&gt;% filter(National_ != &quot;Peninsula Sandstone Fynbos&quot;) %&gt;% st_buffer(dist = 250) #NOTE that st_buffer() makes them polygons, because they now have area! npsf$geometry[1] #The first geometry in npsf ## Geometry set for 1 feature ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: -53918.51 ymin: -3762378 xmax: -53418.51 ymax: -3761878 ## Projected CRS: WGS_1984_Transverse_Mercator ## POLYGON ((-53418.51 -3762128, -53418.86 -376214... #Get the number of unique iNaturalist record numbers length(unique(npsf$id)) ## [1] 16 #Intersect new polygons with veg remnants and filter for those that overlap Peninsula Sandstone Fynbos only npsf &lt;- st_intersection(npsf, vegr) %&gt;% filter(National_.1 == &quot;Peninsula Sandstone Fynbos&quot;) ## Warning: attribute variables are assumed to be spatially constant throughout all ## geometries #Get the number of unique iNaturalist record numbers that overlap PSF length(unique(npsf$id)) ## [1] 11 So a fair proportion of the records are suspiciously close to Peninsula Sandstone Fynbos… 7.15 Within distance and intersect Perhaps a more interesting use of buffering is to see if a species’ locality is within a certain distance of a particular habitat etc. For example, we could ask if a species is associated with riparian zones by buffering either the localities (points) or rivers (lines) and then doing an intersection. But of course there are many ways to skin a cat, and it turns out buffering and intersecting may not be the most efficient here. If we don’t want to pull the attribute data from one dataset to the other we can just use st_intersects() to see if they overlap at all. We can even take it one step further, because sf has the function st_is_within_distance(), which is similar to applying st_buffer() and st_intersects() in one go. Here we’ll use Brabejum stellatifolium (a riparian tree in the Proteaceae) as our focal species and the watercourse layer from the City of Cape Town. #Get the watercourse data water &lt;- st_read(&quot;data/cape_peninsula/Open_Watercourses.geojson&quot;) ## Reading layer `Open_Watercourses&#39; from data source ## `/Users/jasper/GIT/spatial-r/data/cape_peninsula/Open_Watercourses.geojson&#39; ## using driver `GeoJSON&#39; ## Simple feature collection with 10848 features and 11 fields ## Geometry type: MULTILINESTRING ## Dimension: XY ## Bounding box: xmin: 18.31249 ymin: -34.28774 xmax: 18.99045 ymax: -33.47256 ## Geodetic CRS: WGS 84 #Check it&#39;s CRS st_crs(water) ## Coordinate Reference System: ## User input: WGS 84 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## DATUM[&quot;World Geodetic System 1984&quot;, ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;geodetic latitude (Lat)&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;geodetic longitude (Lon)&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4326]] #Call the data directly from iNat bs &lt;- get_inat_obs(taxon_name = &quot;Brabejum stellatifolium&quot;, bounds = c(-35, 18, -33.5, 18.5), maxresults = 1000) #Filter returned observations by a range of attribute criteria bs &lt;- bs %&gt;% filter(positional_accuracy&lt;46 &amp; latitude&lt;0 &amp; !is.na(latitude) &amp; captive_cultivated == &quot;false&quot; &amp; quality_grade == &quot;research&quot;) #See how many records we got nrow(bs) ## [1] 306 #Make the dataframe a spatial object of class = &quot;sf&quot; bs &lt;- st_as_sf(bs, coords = c(&quot;longitude&quot;, &quot;latitude&quot;), crs = 4326) #Note that I had to define the CRS (as Geographic WGS84)!!! Let’s see what we’ve got… #Crop the water courses to the extent of the locality data water &lt;- st_crop(water, bs) ## Warning: attribute variables are assumed to be spatially constant throughout all ## geometries #Plot ggplot() + annotation_map_tile(type = &quot;osm&quot;, progress = &quot;none&quot;) + geom_sf(data = water, colour = &quot;blue&quot;) + geom_sf(data=bs) Hard to tell, but they could all be on rivers? Let’s try st_intersects() without any buffering first to see if they overlap at all. st_intersects(bs, water) %&gt;% unlist() ## integer(0) Oops! We forgot to project our data! bs &lt;- st_transform(bs, st_crs(vegr)) water &lt;- st_transform(water, st_crs(vegr)) st_intersects(bs, water) %&gt;% unlist() ## integer(0) So none of them intersect, but this is not surprising, because lines and points in GIS do not have area, so they can’t really intersect unless you buffer them… Let’s try st_is_within_distance() and set it for 20 metres. Note that I add unlist() %&gt;% unique() so that it gives me a vector of the unique features (i.e. once each) that are within 20m, because the function returns a list and will return the same feature (line/river) multiple times - once for every point (tree) it is within 20m of. st_is_within_distance(bs, water, 20) %&gt;% unlist() %&gt;% unique() ## [1] 346 165 322 290 347 179 101 280 327 328 284 285 592 332 617 507 330 264 351 349 885 ## [22] 294 333 224 281 282 615 19 So it’s given us the list of lines (rivers) within 20m of our points, but that doesn’t tell us how many (or what proportion) of our points are within 20m of a river. Let’s apply the function again, swapping the layers around: st_is_within_distance(water, bs, 20) %&gt;% unlist() %&gt;% unique() ## [1] 293 47 278 294 304 5 23 214 235 244 145 91 219 252 14 229 230 48 54 70 97 ## [22] 113 117 127 141 165 172 173 199 200 271 272 83 86 151 161 164 183 218 221 286 106 ## [43] 144 270 254 1 3 18 22 41 42 44 50 77 78 137 138 139 152 159 194 215 216 ## [64] 245 160 217 146 212 126 95 107 211 213 225 282 So only 75 of the trees are within 20m of the rivers. What about 100m? st_is_within_distance(water, bs, 100) %&gt;% unlist() %&gt;% unique() ## [1] 72 73 98 142 37 233 293 47 278 294 304 5 6 33 63 155 167 188 257 285 23 ## [22] 214 235 244 149 25 156 17 19 20 21 24 27 29 35 36 38 51 59 62 67 85 ## [43] 90 91 99 104 105 123 145 163 197 219 220 236 238 239 240 248 252 256 265 269 32 ## [64] 295 247 273 296 26 14 237 266 267 268 96 229 230 259 196 177 277 222 8 9 15 ## [85] 34 40 48 52 53 54 55 57 58 69 70 80 83 84 89 97 108 113 114 115 117 ## [106] 118 119 120 121 122 127 133 134 141 158 164 165 168 170 171 172 173 178 183 186 199 ## [127] 200 206 207 208 209 210 227 232 242 253 260 262 263 264 271 272 286 288 299 12 31 ## [148] 86 102 140 150 151 161 175 176 185 187 201 202 203 204 205 218 221 234 116 75 106 ## [169] 107 112 144 270 254 3 11 109 110 111 1 2 18 22 41 42 43 44 50 77 78 ## [190] 82 88 92 103 131 137 138 139 152 159 160 194 215 216 245 255 300 217 146 154 212 ## [211] 297 126 39 94 95 93 125 128 129 132 211 213 225 282 231 225 It’s at this point that it’s worth thinking about the scale, precision and accuracy of both the species localities and the watercourse data before drawing any strong conclusions!!! "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
