[["terra.html", "8 Raster GIS operations in R with terra 8.1 Reading in data 8.2 Defining CRS and projecting 8.3 Cropping 8.4 Aggregating / Resampling 8.5 Basic plotting 8.6 Disaggregating 8.7 Raster maths! 8.8 Focal and terrain calculations 8.9 Raster stacks 8.10 Extracting raster to vector 8.11 Rasterizing 8.12 Crosstabulating rasters 8.13 Visualizing multiple datasets on one map 8.14 Cloud Optimized GeoTiffs (COGs)!!! 8.15 Obtaining satellite data from APIs", " 8 Raster GIS operations in R with terra 8.1 Reading in data Ok, now to look at handling rasters. As with sf, the terra package has one function -rast()- that can read in just about any raster file format, which it assigns it’s own class SpatRaster. Let’s get started and read in the digital elevation model (DEM) for the City of Cape Town. library(terra) ## terra 1.8.93 dem &lt;- rast(&quot;data/cape_peninsula/CoCT_10m.tif&quot;) class(dem) ## [1] &quot;SpatRaster&quot; ## attr(,&quot;package&quot;) ## [1] &quot;terra&quot; dem #Typing the name of a &quot;SpatRaster&quot; class data object gives you the details ## class : SpatRaster ## size : 9902, 6518, 1 (nrow, ncol, nlyr) ## resolution : 10, 10 (x, y) ## extent : -64180, 1000, -3804020, -3705000 (xmin, xmax, ymin, ymax) ## coord. ref. : GCS_WGS_1984 ## source : CoCT_10m.tif ## name : 10m_BA ## min value : -35 ## max value : 1590 The coord. ref. field shows GCS_WGS_1984, which is Geographic Coordinates, but perhaps there is a projected CRS too? The extent appears to be in metres, with the eastings being a mix of positive and negative numbers, from which we can deduce that the coordinate reference system may be Transverse Mercator centred on Lo19, as for the other datasets we obtained from the City of Cape Town. Best to make sure! If you just want to know the CRS from a SpatRaster, you just call crs() like so: crs(dem) ## [1] &quot;PROJCRS[\\&quot;GCS_WGS_1984\\&quot;,\\n BASEGEOGCRS[\\&quot;WGS 84\\&quot;,\\n DATUM[\\&quot;World Geodetic System 1984\\&quot;,\\n ELLIPSOID[\\&quot;WGS 84\\&quot;,6378137,298.25722356049,\\n LENGTHUNIT[\\&quot;metre\\&quot;,1]]],\\n PRIMEM[\\&quot;Greenwich\\&quot;,0,\\n ANGLEUNIT[\\&quot;degree\\&quot;,0.0174532925199433]],\\n ID[\\&quot;EPSG\\&quot;,4326]],\\n CONVERSION[\\&quot;Transverse Mercator\\&quot;,\\n METHOD[\\&quot;Transverse Mercator\\&quot;,\\n ID[\\&quot;EPSG\\&quot;,9807]],\\n PARAMETER[\\&quot;Latitude of natural origin\\&quot;,0,\\n ANGLEUNIT[\\&quot;degree\\&quot;,0.0174532925199433],\\n ID[\\&quot;EPSG\\&quot;,8801]],\\n PARAMETER[\\&quot;Longitude of natural origin\\&quot;,19,\\n ANGLEUNIT[\\&quot;degree\\&quot;,0.0174532925199433],\\n ID[\\&quot;EPSG\\&quot;,8802]],\\n PARAMETER[\\&quot;Scale factor at natural origin\\&quot;,1,\\n SCALEUNIT[\\&quot;unity\\&quot;,1],\\n ID[\\&quot;EPSG\\&quot;,8805]],\\n PARAMETER[\\&quot;False easting\\&quot;,0,\\n LENGTHUNIT[\\&quot;metre\\&quot;,1],\\n ID[\\&quot;EPSG\\&quot;,8806]],\\n PARAMETER[\\&quot;False northing\\&quot;,0,\\n LENGTHUNIT[\\&quot;metre\\&quot;,1],\\n ID[\\&quot;EPSG\\&quot;,8807]]],\\n CS[Cartesian,2],\\n AXIS[\\&quot;easting\\&quot;,east,\\n ORDER[1],\\n LENGTHUNIT[\\&quot;metre\\&quot;,1,\\n ID[\\&quot;EPSG\\&quot;,9001]]],\\n AXIS[\\&quot;northing\\&quot;,north,\\n ORDER[2],\\n LENGTHUNIT[\\&quot;metre\\&quot;,1,\\n ID[\\&quot;EPSG\\&quot;,9001]]]]&quot; Messy, but somewhere in there it says “Longitude of natural origin 19” and “Transverse Mercator”… 8.2 Defining CRS and projecting Similar to st_crs(), you can define a projection using the syntax: crs(your_raster) &lt;- \"your_crs\", where the new CRS can be in WKT, and EPSG code, or a PROJ string. For reprojecting, you use the function project(). We’ll look at it later in the section on Cloud Optimized GeoTiffs. 8.3 Cropping Ok, before we try to anything with this dataset, let’s think about how big it is… One of the outputs of calling dem was the row reading dimensions : 9902, 6518, 1 (nrow, ncol, nlyr). Given that we are talking about 10m pixels, this information tells us that the extent of the region is roughly 100km by 65km and that there are ~65 million pixels! No wonder the original file was ~130MB (I reduced the one I shared with you slightly). While R can handle this, it does become slow when dealing with very large files. There are many ways to improve the efficiency of handling big rasters in R (see this slightly dated post for details if you’re interested), but for the purposes of this tutorial we’re going to take the easy option and just crop it to a smaller extent, like so: dem &lt;- crop(dem, ext(c(-66642.18, -44412.18, -3809853.29, -3750723.29))) Note that the crop() function requires us to pass it an object of class SpatExtent. Just like st_crop() from sf, crop() can derive the extent from another data object. One silly difference, is that if you pass it the coordinates of the extent manually (as above), you first need to pass it to the ext() function, and they need to follow the order xmin, xmax, ymin, ymax (as opposed to xmin, ymin, xmax, ymax as you do for st_crop()). Keep your eye out for these little differences, because they will trip you up… Ok, so how big is our dataset now? dem ## class : SpatRaster ## size : 5330, 1977, 1 (nrow, ncol, nlyr) ## resolution : 10, 10 (x, y) ## extent : -64180, -44410, -3804020, -3750720 (xmin, xmax, ymin, ymax) ## coord. ref. : GCS_WGS_1984 ## source(s) : memory ## varname : CoCT_10m ## name : 10m_BA ## min value : -15 ## max value : 1084 …still &gt;10 million pixels… 8.4 Aggregating / Resampling Do we need 10m data? If your analysis doesn’t need such fine resolution data, you can resample the raster to a larger pixel size, like 30m. The aggregate() function does this very efficiently, like so: dem30 &lt;- aggregate(dem, fact = 3, fun = mean) ## |---------|---------|---------|---------|========================================= Here I’ve told it to aggregate by a factor of 3 (i.e. bin 9 neighbouring pixels (3x3) into one) and to assign the bigger pixel the mean of the 9 original pixels. This obviously results in some data loss, but that can be acceptable, depending on the purpose of your analysis. Note that you can pass just about any function to fun =, like min(), max() or even your own function. dem30 ## class : SpatRaster ## size : 1777, 659, 1 (nrow, ncol, nlyr) ## resolution : 30, 30 (x, y) ## extent : -64180, -44410, -3804030, -3750720 (xmin, xmax, ymin, ymax) ## coord. ref. : GCS_WGS_1984 ## source(s) : memory ## name : 10m_BA ## min value : -15.000 ## max value : 1083.556 Ok, so we’ve reduced the size of the raster by a factor of 9 and only have a little over 1 million pixels to deal with. Much more reasonable! Now let’s have a look at what we’re dealing with. 8.5 Basic plotting Now that we’ve reduced the size of the dataset, we can try the base plotting function: plot(dem30) Or with the Tidyverse… Note that ggplot() doesn’t accept rasters, so we need to give it a dataframe with x and y columns for the coordinates, and a column containing the values to plot. This is easily done by coercing the raster into a dataframe, like so: #call tidyverse libraries and plot library(tidyverse) ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── ## ✔ dplyr 1.2.0 ✔ readr 2.2.0 ## ✔ forcats 1.0.1 ✔ stringr 1.6.0 ## ✔ ggplot2 4.0.2 ✔ tibble 3.3.1 ## ✔ lubridate 1.9.5 ✔ tidyr 1.3.2 ## ✔ purrr 1.2.1 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ tidyr::extract() masks terra::extract() ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors dem30 %&gt;% as.data.frame(xy = TRUE) %&gt;% ggplot() + geom_raster(aes(x = x, y = y, fill = `10m_BA`)) # Note that I had to know that the column name for the elevation data is &quot;10m_BA&quot;... and that you need to use ` ` around a variable name when feeding it to a function if it starts with a digit. Ok, how different does our 30m raster look to the 10m version? dem %&gt;% as.data.frame(xy = TRUE) %&gt;% ggplot() + geom_raster(aes(x = x, y = y, fill = `10m_BA`)) Not noticeably different at this scale! 8.6 Disaggregating One way to explore the degree of data loss is to disagg() our 30m DEM back to 10m and then compare it to the original. dem10 &lt;- disagg(dem30, fact = 3, method = &quot;bilinear&quot;) Note that I’ve tried to use bilinear interpolation to give it a fair chance of getting nearer the original values. You can google this on your own, but it essentially smooths the data by averaging across neighbouring pixels. Now, how can I compare my two 10m rasters? 8.7 Raster maths! The raster and terra packages make this easy, because you can do maths with rasters, treating them as variables in an equation. This means we can explore the data loss by calculating the difference between the original and disaggregated DEMS. Note that when aggregating you often lose some of the cells along the edges, and that you can’t do raster maths on rasters with different extents… We can fix this by cropping the larger raster with the smaller first. dem10 &lt;- crop(dem10, dem) diff &lt;- dem - dem10 #maths with rasters! And plot the result! diff %&gt;% as.data.frame(xy = TRUE) %&gt;% ggplot() + geom_raster(aes(x = x, y = y, fill = `10m_BA`)) If you look really closely, you’ll see the outline of the cliffs of Table Mountain, where you’d expect the data loss to be worst. The colour ramp tells us that the worst distortion was up to 100m, or about 10% of the elevation range in this dataset, but don’t be fooled by the extremes! Let’s have a look at all the values as a histogram. diff %&gt;% as.data.frame(xy = TRUE) %&gt;% ggplot() + geom_histogram(aes(`10m_BA`)) ## `stat_bin()` using `bins = 30`. Pick better value `binwidth`. Looks like most values are within 10 or so metres of their original values, so the data loss really wasn’t that bad! 8.8 Focal and terrain calculations In addition to maths with multiple rasters, you can do all kinds of calculations within a raster using focal(). This essentially applies a moving window, calculating values for a neighbourhood of cells as it goes, using whatever function you supply (mean, max, your own, etc). The function terrain() is a special case of focal(), optimized for calculating slope, aspect, topographic position index (TPI), topographic roughness index (TRI), roughness, or flow direction. Here I’ll calculate the slope and aspect so that we can pass them to the function shade() to make a pretty hillshade layer. aspect &lt;- terrain(dem30, &quot;aspect&quot;, unit = &quot;radians&quot;) slope &lt;- terrain(dem30, &quot;slope&quot;, unit = &quot;radians&quot;) hillshade &lt;- shade(slope, aspect) plot(hillshade) Probably prettier with Tidyverse: hillshade %&gt;% as.data.frame(xy = TRUE) %&gt;% ggplot() + geom_raster(aes(x = x, y = y, fill = hillshade)) + #note that the hillshade column name in this case is &quot;hillshade&quot; scale_fill_gradient(low = &quot;grey10&quot;, high = &quot;grey90&quot;) Nice ne? 8.9 Raster stacks Another nice thing about rasters is that if you have multiple rasters “on the same grid” (i.e. with the same pixel size, extent and CRS) then you can stack them and work with them as a single object. library(raster) users will be familiar with stack(), but in terra you just use the base function c(), like so: dstack &lt;- c(dem30, slope, aspect, hillshade) dstack ## class : SpatRaster ## size : 1777, 659, 4 (nrow, ncol, nlyr) ## resolution : 30, 30 (x, y) ## extent : -64180, -44410, -3804030, -3750720 (xmin, xmax, ymin, ymax) ## coord. ref. : GCS_WGS_1984 ## source(s) : memory ## names : 10m_BA, slope, aspect, hillshade ## min values : -15.000, 0.000000, 0.000000, -0.4906481 ## max values : 1083.556, 1.370826, 6.283185, 0.9999974 As you can see the “dimensions” now report 4 layers, and there are 4 names. Some of the names don’t look all that informative though, so let’s rename them. names(dstack) &lt;- c(&quot;elevation&quot;, &quot;slope&quot;, &quot;aspect&quot;, &quot;shade&quot;) plot(dstack) 8.10 Extracting raster to vector Ok, enough fooling around. More often than not, we just want to extract data from rasters for further analyses (e.g. climate layers, etc), so let’s cover that base here. Extract to points First, let’s get some points for two species in the Proteaceae, Protea cynaroides and Leucadendron laureolum… library(rinat) library(sf) ## Linking to GEOS 3.13.0, GDAL 3.8.5, PROJ 9.5.1; sf_use_s2() is TRUE #Call data for two species directly from iNat pc &lt;- get_inat_obs(taxon_name = &quot;Protea cynaroides&quot;, bounds = c(-35, 18, -33.5, 18.5), maxresults = 1000) ll &lt;- get_inat_obs(taxon_name = &quot;Leucadendron laureolum&quot;, bounds = c(-35, 18, -33.5, 18.5), maxresults = 1000) #Combine the records into one dataframe pc &lt;- rbind(pc,ll) #Filter returned observations by a range of attribute criteria pc &lt;- pc %&gt;% filter(positional_accuracy&lt;46 &amp; latitude&lt;0 &amp; !is.na(latitude) &amp; captive_cultivated == &quot;false&quot; &amp; quality_grade == &quot;research&quot;) #Make the dataframe a spatial object of class = &quot;sf&quot; pc &lt;- st_as_sf(pc, coords = c(&quot;longitude&quot;, &quot;latitude&quot;), crs = 4326) #Set to the same projection as the elevation data pc &lt;- st_transform(pc, crs(dem30)) Now let’s extract the data to the points. NOTE!!! terra doesn’t play nicely with sf objects at this stage, so you need to coerce them into terra’s own vector format using vect(). dat &lt;- terra::extract(dem30, vect(pc)) # note vect() head(dat) ## ID 10m_BA ## 1 1 750.5556 ## 2 2 666.4444 ## 3 3 765.2222 ## 4 4 764.4444 ## 5 5 1067.0000 ## 6 6 749.3333 Nice, but not all that handy on it’s own. Let’s add the elevation column to our points layer, so we can match it with the species names and plot. pc$dem &lt;- dat$`10m_BA` pc %&gt;% ggplot() + geom_boxplot(aes(scientific_name, dem)) ## Warning: Removed 2 rows containing non-finite outside the scale range ## (`stat_boxplot()`). A clear separation in the preferred elevation range between the two species. Ok, that’s handy, but what if we have lots of rasters? We don’t want to have to do that for every raster! This is where raster stacks come into their own! #extract from stack dat &lt;- terra::extract(dstack, vect(pc)) #bind columns to points to match the names edat &lt;- cbind(as.data.frame(pc), dat) #have a quick look at the data head(edat) ## scientific_name datetime description ## 1 Protea cynaroides 2026-02-22 07:25:42 +0200 ## 2 Protea cynaroides 2026-02-23 07:58:39 +0200 ## 3 Protea cynaroides 2026-02-01 09:26:03 +0200 ## 4 Protea cynaroides 2026-02-01 07:06:21 +0200 ## 5 Protea cynaroides 2025-05-16 11:56:12 +0200 ## 6 Protea cynaroides 2026-02-18 10:27:00 +0200 ## place_guess ## 1 Cape Town, Western Cape, ZA ## 2 Kasteelspoort, Table Mountain (Nature Reserve), Cape Town, South Africa ## 3 Table Mountain National Park, Cape Town, Western Cape, ZA ## 4 Table Mountain National Park, ZA-WC-CT, ZA-WC, ZA ## 5 Cape Town, Western Cape, ZA ## 6 Table Mountain (Nature Reserve), Cape Town, South Africa ## tag_list common_name url ## 1 King Protea https://www.inaturalist.org/observations/339993183 ## 2 King Protea https://www.inaturalist.org/observations/339907239 ## 3 King Protea https://www.inaturalist.org/observations/339868196 ## 4 King Protea https://www.inaturalist.org/observations/339743109 ## 5 King Protea https://www.inaturalist.org/observations/339518035 ## 6 King Protea https://www.inaturalist.org/observations/339446973 ## image_url ## 1 https://inaturalist-open-data.s3.amazonaws.com/photos/618616993/medium.jpg ## 2 https://inaturalist-open-data.s3.amazonaws.com/photos/618440571/medium.jpg ## 3 https://inaturalist-open-data.s3.amazonaws.com/photos/618360202/medium.jpg ## 4 https://inaturalist-open-data.s3.amazonaws.com/photos/618103348/medium.jpg ## 5 https://inaturalist-open-data.s3.amazonaws.com/photos/617650655/medium.jpg ## 6 https://static.inaturalist.org/photos/617504263/medium.jpg ## user_login id species_guess iconic_taxon_name taxon_id ## 1 grahamf 339993183 Giant Protea Plantae 132848 ## 2 justinhawthorne 339907239 Giant Protea Plantae 132848 ## 3 samshu 339868196 Giant Protea Plantae 132848 ## 4 migsgreenworld 339743109 Giant Protea Plantae 132848 ## 5 lidkaa1969 339518035 King Protea Plantae 132848 ## 6 bergwind 339446973 King Protea Plantae 132848 ## num_identification_agreements num_identification_disagreements ## 1 2 0 ## 2 2 0 ## 3 2 0 ## 4 4 0 ## 5 4 0 ## 6 3 0 ## observed_on_string observed_on time_observed_at time_zone ## 1 2026-02-22 07:25:42 2026-02-22 2026-02-22 05:25:42 UTC Pretoria ## 2 2026-02-23 07:58:39 2026-02-23 2026-02-23 05:58:39 UTC Pretoria ## 3 2026-02-01 09:26:03+02:00 2026-02-01 2026-02-01 07:26:03 UTC Pretoria ## 4 2026-02-01 07:06:21+02:00 2026-02-01 2026-02-01 05:06:21 UTC Pretoria ## 5 2025-05-16 11:56:12 2025-05-16 2025-05-16 09:56:12 UTC Pretoria ## 6 2026/02/18 10:27 AM 2026-02-18 2026-02-18 08:27:00 UTC Pretoria ## positional_accuracy public_positional_accuracy geoprivacy taxon_geoprivacy ## 1 3 3 open ## 2 4 4 open ## 3 2 2 open ## 4 45 45 open ## 5 4 4 open ## 6 4 4 open ## coordinates_obscured positioning_method positioning_device user_id ## 1 false 9450735 ## 2 false gps gps 2040203 ## 3 false 1670085 ## 4 false 4988081 ## 5 false 10135981 ## 6 false 850060 ## user_name created_at updated_at ## 1 Graham Fehrsen 2026-02-24 05:33:03 UTC 2026-02-24 05:57:58 UTC ## 2 Justin Hawthorne 2026-02-23 16:45:36 UTC 2026-02-24 11:19:47 UTC ## 3 2026-02-23 09:35:54 UTC 2026-02-23 12:04:12 UTC ## 4 2026-02-22 15:42:35 UTC 2026-02-23 08:24:18 UTC ## 5 Lidia 2026-02-21 03:57:35 UTC 2026-02-23 08:24:34 UTC ## 6 Dave McDonald 2026-02-20 16:39:55 UTC 2026-02-23 08:24:31 UTC ## quality_grade license sound_url oauth_application_id captive_cultivated ## 1 research CC-BY-NC NA 843 false ## 2 research CC-BY-NC NA 2 false ## 3 research CC-BY-NC NA 3 false ## 4 research CC-BY NA 3 false ## 5 research CC-BY-NC NA 843 false ## 6 research NA NA false ## geometry dem ID elevation slope aspect ## 1 POINT (-54516.04 -3760925) 750.5556 1 750.5556 0.06695751 4.4037381 ## 2 POINT (-56178.58 -3760699) 666.4444 2 666.4444 0.70864517 3.8689078 ## 3 POINT (-55601.45 -3760747) 765.2222 3 765.2222 0.23420278 3.8803214 ## 4 POINT (-52259.22 -3758842) 764.4444 4 764.4444 0.50107646 4.0612802 ## 5 POINT (-54693.01 -3759405) 1067.0000 5 1067.0000 0.12894329 0.4349015 ## 6 POINT (-54526.63 -3760927) 749.3333 6 749.3333 0.05253004 3.8397131 ## shade ## 1 0.6911505 ## 2 0.1931229 ## 3 0.5664818 ## 4 0.4143142 ## 5 0.7836968 ## 6 0.6776900 #to make a panel plot, select columns we want and tidy data into long format edat &lt;- edat %&gt;% dplyr::select(scientific_name, elevation, slope, aspect, shade) %&gt;% pivot_longer(c(elevation, slope, aspect, shade)) #panel boxplot of the variables extracted edat %&gt;% ggplot() + geom_boxplot(aes(scientific_name, value)) + facet_wrap(~name, scales = &quot;free&quot;) ## Warning: Removed 8 rows containing non-finite outside the scale range ## (`stat_boxplot()`). Something I should have mentioned is that if you would like each point to sample a larger region you can add a buffer = argument to the extract() function, and a function (fun =) to summarize the neighbourhood of pixels sampled, like so: pc$dem30 &lt;- terra::extract(dem30, vect(pc), buffer = 200, fun = mean)$`10m_BA` #Note the sneaky use of $ to access the column I want pc %&gt;% ggplot() + geom_boxplot(aes(scientific_name, dem30)) ## Warning: Removed 2 rows containing non-finite outside the scale range ## (`stat_boxplot()`). Extract to polygons Now let’s try that with our vegetation polygons. #Get historical vegetation layer veg &lt;- st_read(&quot;data/cape_peninsula/veg/Vegetation_Indigenous.shp&quot;) ## Reading layer `Vegetation_Indigenous&#39; from data source ## `/Users/jasper/GIT/spatial-r/data/cape_peninsula/veg/Vegetation_Indigenous.shp&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 1325 features and 5 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: -63972.95 ymin: -3803535 xmax: 430.8125 ymax: -3705149 ## Projected CRS: WGS_1984_Transverse_Mercator #Crop to same extent as DEM veg &lt;- st_crop(veg, ext(dem30)) #Note that I just fed it the extent of the DEM ## Warning: attribute variables are assumed to be spatially constant throughout ## all geometries #Best to dissolve polygons first - otherwise you get repeat outputs for each polygon within each veg type vegsum &lt;- veg %&gt;% group_by(National_) %&gt;% summarize() #Do extraction - note the summary function vegdem &lt;- terra::extract(dem30, vect(vegsum), fun = mean, na.rm = T) ## Warning: [extract] transforming vector data to the CRS of the raster #Combine the names and vector extracted means into a dataframe vegdem &lt;- cbind(vegdem, vegsum$National_) #Rename the columns to something meaningful names(vegdem) &lt;- c(&quot;ID&quot;, &quot;Mean elevation (m)&quot;, &quot;Vegetation type&quot;) #Plot vegdem %&gt;% ggplot() + geom_col(aes(y = `Mean elevation (m)`, x = `Vegetation type`)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) Ok, I did a lot of things there…, but you get it right? Note that I applied a function to the extract() to summarize the output, because each polygon usually returns multiple raster cell values. You can choose (or code up) your own function. Here’s a different approach… 8.11 Rasterizing Rasterizing essentially means turning a vector layer into a raster. To rasterize, you need an existing raster grid to rasterize to, like dem30 in this case. #Make the vegetation type a factor vegsum$National_ &lt;- as.factor(vegsum$National_) #Rasterize vegras &lt;- rasterize(vect(vegsum), dem30, field = &quot;National_&quot;) #Plot vegras %&gt;% as.data.frame(xy = TRUE) %&gt;% ggplot() + geom_raster(aes(x = x, y = y, fill = National_)) I’m sure this plot is a surprise to those who worked with raster. Usually rasters want to work with numbers. terra can work with (and rasterize) data of class “factor”, opening up all kinds of opportunities. But once you have a raster of class factor and a raster with values, you can stack and unpack them into a dataframe and analyse them as you would usually. #Stack the two rasters vegdem &lt;- c(vegras, dem30) #Convert to data frame vegdem_df &lt;- as.data.frame(vegdem) #Plot vegdem_df %&gt;% group_by(National_) %&gt;% summarise(`Mean elevation (m)` = mean(`10m_BA`, na.rm = T)) %&gt;% ggplot() + geom_col(aes(y = `Mean elevation (m)`, x = `National_`)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) Tadaa! Same figure we made before, but we took a different route this time. Note that the second approach doesn’t require us to summarize the raster values for each polygon first, because we can just convert the whole stack to a dataframe and do the summary (if we want it) in R with dplyr instead. This is a powerful way to work with rasters, and allows you to use all the tools of the Tidyverse for data manipulation and visualization. # #Plot library(ggridges) vegdem_df %&gt;% ggplot(aes(x = `10m_BA`, y = `National_`, fill = `National_`)) + geom_density_ridges() + theme_ridges() + theme(legend.position = &quot;none&quot;) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + xlim(0, 300) + xlab(&quot;Elevation (m)&quot;) + ylab(&quot;Vegetation type&quot;) ## Picking joint bandwidth of 4.05 # vegdem_df %&gt;% # #group_by(National_) %&gt;% # #summarise(`Mean elevation (m)` = mean(`10m_BA`, na.rm = T)) %&gt;% # ggplot() + # geom_density(aes(y = `10m_BA`, x = `National_`)) + # theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + # facet_wrap(~National_, scales = &quot;free_x&quot;) The ability to turn stacked rasters into dataframes and analyse them “non-spatially” can be very powerful. There are also a bunch of functions that make this even easier. 8.12 Crosstabulating rasters Say we had two or more rasters that each contained factor data (i.e. discrete) and we wanted to look at the frequency of associations between the different sets of classes? We can very easily do this with the function crosstab(). Here’s an example looking at slope classes by vegetation type. First, we classify our slope raster into discrete classes, then we cross-tabulate the classified slope raster with our raster of vegetation types. # Classify the slope raster into 5 classes slopeclass &lt;- classify(slope, c(0, 0.3, 0.6, 0.9, 1.2, 1.4), include.lowest=TRUE) aspectclass &lt;- classify(aspect, c(0, 2, 4, 6.5), include.lowest=TRUE) plot(slopeclass) # Crosstabulate slope with veg type crosstab(c(vegras, slopeclass, aspectclass)) ## , , aspect = (2 - 4] ## ## slope ## National_ (0.3 - 0.6] (0.6 - 0.9] (0.9 - 1.2] ## Beach - FalseBay 277 84 29 ## Cape Estuarine Salt Marshes 0 0 0 ## Cape Flats Dune Strandveld - False Bay 1413 317 31 ## Cape Flats Dune Strandveld - West Coast 0 0 0 ## Cape Flats Sand Fynbos 0 0 0 ## Cape Lowland Freshwater Wetlands 0 0 0 ## Hangklip Sand Fynbos 1835 133 6 ## Peninsula Granite Fynbos - North 993 87 0 ## Peninsula Granite Fynbos - South 3980 850 151 ## Peninsula Sandstone Fynbos 19730 6198 1207 ## Peninsula Shale Fynbos 579 148 21 ## Peninsula Shale Renosterveld 619 0 0 ## RECLAIMED 21 3 0 ## Southern Afrotemperate Forest 1303 374 57 ## slope ## National_ (1.2 - 1.4] [0 - 0.3] ## Beach - FalseBay 0 1568 ## Cape Estuarine Salt Marshes 0 54 ## Cape Flats Dune Strandveld - False Bay 0 13349 ## Cape Flats Dune Strandveld - West Coast 0 1741 ## Cape Flats Sand Fynbos 0 33815 ## Cape Lowland Freshwater Wetlands 0 1558 ## Hangklip Sand Fynbos 0 10325 ## Peninsula Granite Fynbos - North 0 546 ## Peninsula Granite Fynbos - South 16 22278 ## Peninsula Sandstone Fynbos 55 50268 ## Peninsula Shale Fynbos 0 4404 ## Peninsula Shale Renosterveld 0 2635 ## RECLAIMED 0 2060 ## Southern Afrotemperate Forest 3 1058 ## ## , , aspect = (4 - 6.5] ## ## slope ## National_ (0.3 - 0.6] (0.6 - 0.9] (0.9 - 1.2] ## Beach - FalseBay 66 65 8 ## Cape Estuarine Salt Marshes 0 0 0 ## Cape Flats Dune Strandveld - False Bay 946 147 8 ## Cape Flats Dune Strandveld - West Coast 0 0 0 ## Cape Flats Sand Fynbos 0 0 0 ## Cape Lowland Freshwater Wetlands 0 0 0 ## Hangklip Sand Fynbos 277 2 0 ## Peninsula Granite Fynbos - North 8096 364 3 ## Peninsula Granite Fynbos - South 4597 830 127 ## Peninsula Sandstone Fynbos 17091 6209 1621 ## Peninsula Shale Fynbos 784 11 0 ## Peninsula Shale Renosterveld 1065 56 0 ## RECLAIMED 6 0 0 ## Southern Afrotemperate Forest 144 43 19 ## slope ## National_ (1.2 - 1.4] [0 - 0.3] ## Beach - FalseBay 0 776 ## Cape Estuarine Salt Marshes 0 28 ## Cape Flats Dune Strandveld - False Bay 0 16054 ## Cape Flats Dune Strandveld - West Coast 0 2739 ## Cape Flats Sand Fynbos 0 29762 ## Cape Lowland Freshwater Wetlands 0 3498 ## Hangklip Sand Fynbos 0 15284 ## Peninsula Granite Fynbos - North 0 8633 ## Peninsula Granite Fynbos - South 0 13365 ## Peninsula Sandstone Fynbos 67 61386 ## Peninsula Shale Fynbos 0 1001 ## Peninsula Shale Renosterveld 0 9381 ## RECLAIMED 0 2119 ## Southern Afrotemperate Forest 0 180 ## ## , , aspect = [0 - 2] ## ## slope ## National_ (0.3 - 0.6] (0.6 - 0.9] (0.9 - 1.2] ## Beach - FalseBay 17 16 3 ## Cape Estuarine Salt Marshes 0 0 0 ## Cape Flats Dune Strandveld - False Bay 531 356 62 ## Cape Flats Dune Strandveld - West Coast 0 0 0 ## Cape Flats Sand Fynbos 3 0 0 ## Cape Lowland Freshwater Wetlands 0 0 0 ## Hangklip Sand Fynbos 707 6 2 ## Peninsula Granite Fynbos - North 1948 57 5 ## Peninsula Granite Fynbos - South 4848 399 57 ## Peninsula Sandstone Fynbos 21704 8267 1339 ## Peninsula Shale Fynbos 1626 181 24 ## Peninsula Shale Renosterveld 757 11 0 ## RECLAIMED 9 0 0 ## Southern Afrotemperate Forest 301 66 2 ## slope ## National_ (1.2 - 1.4] [0 - 0.3] ## Beach - FalseBay 0 263 ## Cape Estuarine Salt Marshes 0 41 ## Cape Flats Dune Strandveld - False Bay 0 12030 ## Cape Flats Dune Strandveld - West Coast 0 2682 ## Cape Flats Sand Fynbos 0 45363 ## Cape Lowland Freshwater Wetlands 0 1548 ## Hangklip Sand Fynbos 0 8038 ## Peninsula Granite Fynbos - North 0 2266 ## Peninsula Granite Fynbos - South 0 27984 ## Peninsula Sandstone Fynbos 69 48492 ## Peninsula Shale Fynbos 0 5255 ## Peninsula Shale Renosterveld 0 11953 ## RECLAIMED 0 2257 ## Southern Afrotemperate Forest 0 296 This function is particularly useful for something like comparing land cover datasets from 2 time points. Also have a look at freq and zonal. 8.13 Visualizing multiple datasets on one map What about if we want to plot multiple datasets on one map? This is easy, if you can feed each dataset into a separate ggplot function. Here’s the veg types with contours and the iNaturalist records we retrieved earlier. ggplot() + geom_raster(data = as.data.frame(vegras, xy = TRUE), aes(x = x, y = y, fill = National_)) + geom_contour(data = as.data.frame(dem30, xy = TRUE), aes(x = x, y = y, z = `10m_BA`), breaks = seq(0, 1100, 100), colour = &quot;black&quot;) + geom_sf(data=pc, colour = &quot;white&quot;, size = 0.5) For more inspiration on mapping with R, check out https://slingsby-maps.myshopify.com/. I’ve been generating the majority of the basemap (terrain colour, hillshade, contours, streams, etc) for these in R for the past few years. 8.14 Cloud Optimized GeoTiffs (COGs)!!! I thought I’d add this as a bonus section, reinforcing the value of standardized open metadata and file formats from the Data Management module. First, let’s open a connection to our COG, which is stored in the cloud. To do this, we need to pass a URL to the file’s online location to terra. cog.url &lt;- &quot;/vsicurl/https://mnemosyne.somisana.ac.za/osgeo/saeon_rgb/grootbos.tif&quot; grootbos &lt;- rast(cog.url) grootbos ## class : SpatRaster ## size : 100024, 121627, 3 (nrow, ncol, nlyr) ## resolution : 0.08, 0.08 (x, y) ## extent : 35640.41, 45370.57, -3828176, -3820175 (xmin, xmax, ymin, ymax) ## coord. ref. : LO19 ## source : grootbos.tif ## colors RGB : 1, 2, 3 ## names : grootbos_1, grootbos_2, grootbos_3 This has given us the metadata about the file, but has not read it into R’s memory. The file is ~1.8GB so it would do bad things if we tried to read the whole thing in… Now let’s retrieve a subset of the file. To do this we need to make a vector polygon for our region of interest (ROI), like so: roi &lt;- vect(data.frame(lon = c(19.433975, 19.436451), lat = c(-34.522733, -34.520735)), crs = &quot;epsg:4326&quot;) And transform it to the same projection as the COG: roi &lt;- terra::project(roi, crs(grootbos)) And then extract our ROI roi_ras &lt;- crop(grootbos, roi) roi_ras ## class : SpatRaster ## size : 2758, 2853, 3 (nrow, ncol, nlyr) ## resolution : 0.08, 0.08 (x, y) ## extent : 39845.61, 40073.85, -3821732, -3821512 (xmin, xmax, ymin, ymax) ## coord. ref. : LO19 ## source(s) : memory ## colors RGB : 1, 2, 3 ## varname : grootbos ## names : grootbos_1, grootbos_2, grootbos_3 ## min values : 28, 47, 56 ## max values : 255, 255, 255 Now we have a raster with 3 layers in memory. There are Red Green and Blue, so we should be able to plot them, like so: plotRGB(roi_ras) This somewhat arbitrary looking site is where we did some fieldwork in the Grootbos Private Nature Reserve with the 2022 class… 8.15 Obtaining satellite data from APIs There are also R packages like MODISTools that allow you to query the online databases. MODISTools interfaces with the ‘MODIS Land Products Subsets’ Web Services to download various products. In this case we’ll be downloading the “MOD13Q1” product, which is the Vegetation Indices product for the Terra satellite, generated every 16 days at 250 meter (m) spatial resolution. The algorithm chooses the best available pixel value from all (daily) the acquisitions from the 16 day period, minimizing clouds, low view angle, and selecting the highest NDVI/EVI value. WARNING! This code can take a while to run! Hence, I have wrapped it in an if() statement that tells the code not to run if the file already exists. if(!file.exists(&quot;data/MODISdat_batch_30Jan2023.csv&quot;)) # if the file does not exist, then run... otherwise do nothing... { library(MODISTools) sites &lt;- data.frame(site_name = c(&quot;grassy field&quot;, &quot;invasion&quot;, &quot;renosterveld&quot;, &quot;sand&quot;, &quot;sandstone&quot;, &quot;limestone&quot;), lat = c(-34.375052, -34.386014, -34.374259, -34.3961, -34.3748, -34.4309), lon = c(20.531749, 20.534986, 20.504233, 20.5494, 20.5428, 20.5666)) ### Here&#39;s some code if you want to use an existing layer of points instead of entering them manually # sites &lt;- st_read(&quot;/home/jasper/GIT/BIO3018F/prac/Potberg_prac_sites.kml&quot;) # sites &lt;- data.frame(site_name = sites$Name, lat = st_coordinates(sites)[,2], lon = st_coordinates(sites)[,1]) dat &lt;- mt_batch_subset(df = sites, product = &quot;MOD13Q1&quot;, band = &quot;250m_16_days_NDVI&quot;, internal = TRUE, start = &quot;2000-01-01&quot;, end = &quot;2023-01-30&quot;) write_csv(dat, &quot;data/MODISdat_batch_30Jan2023.csv&quot;) } Plot all time series read_csv(&quot;data/MODISdat_batch_30Jan2023.csv&quot;) %&gt;% ggplot(aes(x = calendar_date, y = value*0.0001)) + geom_line() + # geom_point() + facet_wrap(.~ site) + ylab(&quot;NDVI&quot;) + ylim(0.2, 0.9) ## Warning: Removed 1 row containing missing values or values outside the scale range ## (`geom_line()`). There are many more complex spatial and remote sensing analyses you can do by interaction with the cloud from R. Here are some links to a few: Cloud-based processing of satellite image collections with rstac and gdalcubes Run Google Earth Engine from R with rgee Obtain spatial data from ESRI REST APIs in R or see package arcpullr There are many more!!! "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
